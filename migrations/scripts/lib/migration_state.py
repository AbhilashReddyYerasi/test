from pathlib import Path
from typing import Dict, List, Optional

from yaml import dump, load

try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader

from dataclasses import dataclass

from .config import SourceDataConfig


@dataclass
class MigrationTableDiff:
    """Represents the diff between the migration state and configuration for a given table."""

    deleted_columns: List[Dict]
    added_columns: List[Dict]
    changed_columns: List[Dict]
    changed_filename: Optional[str]

    def has_changed(self) -> bool:
        return (
            len(self.deleted_columns)
            + len(self.added_columns)
            + len(self.changed_columns)
        ) > 0 or self.changed_filename is not None


class MigrationState:
    """Manages the state for previously autogenerated migrations"""

    def __init__(
        self, migration_root_path: Path, state_file_path: Optional[Path] = None
    ):
        """
        Creates a new MigrationState object tracking the state of autogenerated migrations.

        Parameters:
            migration_root_path: Root path of the schemachange project
            state_file_path: Optional path to the stored state file (default: migration_root_path/state.yaml)
        """
        self.migration_root_path = migration_root_path

        if state_file_path:
            self.state_file = state_file_path
        else:
            self.state_file = migration_root_path / "state.yaml"

        if self.state_file.exists():
            self.state = load(self.state_file.read_text(), Loader)
        else:
            self.state = dict()

    def save(self):
        """Saves the current migration state. If the state is empty any existing state.yaml file will be deleted."""
        if len(self.state):
            self.state_file.write_text(dump(self.state))
        else:
            self.state_file.unlink(missing_ok=True)

    def table_exists(self, table_name: str) -> bool:
        """Checks if a table with table_name exists in the state."""
        return table_name in self.state

    def update_state(self, table_name: str, config: SourceDataConfig):
        """Updated the configuration for a given table in the state

        Parameters:
            table_name: Name of the table to update
            config: The new configuration
        """
        self.state[table_name] = config.to_jinja_context()

    def get_table_diff(
        self, table_name: str, new_config: SourceDataConfig
    ) -> MigrationTableDiff:
        """Returns the diff for table_name between the current state and the new_config

        Parameters:
            table_name: Name of the table to compare
            new_config: New configuration to compare with the current state

        Returns:
            (MigrationTableDiff): Difference between the current state and new_config
        """
        new_config = new_config.to_jinja_context()
        old_config = self.state.get(table_name, dict())

        old_columns = {c["name"]: c for c in old_config.get("columns", [])}
        new_columns = {c["name"]: c for c in new_config["columns"]}

        deleted_columns = [c for k, c in old_columns.items() if k not in new_columns]
        added_columns = [c for k, c in new_columns.items() if k not in old_columns]
        changed_columns = [
            c
            for k, c in new_columns.items()
            if k in old_columns
            and (
                new_columns[k]["type"] != old_columns[k]["type"]
                or new_columns[k].get("transformation")
                != old_columns[k].get("transformation")
            )
        ]

        file_name_has_changed = old_config.get("file_name") != new_config["file_name"]

        return MigrationTableDiff(
            deleted_columns=deleted_columns,
            added_columns=added_columns,
            changed_columns=changed_columns,
            changed_filename=new_config["file_name"] if file_name_has_changed else None,
        )

    def get_migration_version(self) -> int:
        """Returns the version number for the next migration to add"""
        return (
            max(
                int(f.name.split("__")[0].replace("V", ""))
                for f in self.migration_root_path.glob("**/V*.sql*")
            )
            + 1
        )
